/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef indexfs_TYPES_H
#define indexfs_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace indexfs {

typedef int16_t TNumServer;

typedef int64_t TInodeID;

class OID;

class OIDS;

class StatInfo;

class LookupInfo;

class EntryList;

class ScanResult;

class ScanPlusResult;

class OpenResult;

class ReadResult;

class WriteResult;

class FileNotFoundException;

class FileAlreadyExistsException;

class UnrecognizedDirectoryError;

class WrongServerError;

class DirectoryExpectedError;

class FileExpectedError;

class IOError;

class ServerInternalError;

class IllegalPathException;

class ServerRedirectionException;

class ParentPathNotFoundException;

class ParentPathNotDirectoryException;


class OID : public virtual ::apache::thrift::TBase {
 public:

  OID(const OID&);
  OID& operator=(const OID&);
  OID() : path_depth(0), dir_id(0), obj_name() {
  }

  virtual ~OID() throw();
  int16_t path_depth;
  int64_t dir_id;
  std::string obj_name;

  void __set_path_depth(const int16_t val);

  void __set_dir_id(const int64_t val);

  void __set_obj_name(const std::string& val);

  bool operator == (const OID & rhs) const
  {
    if (!(path_depth == rhs.path_depth))
      return false;
    if (!(dir_id == rhs.dir_id))
      return false;
    if (!(obj_name == rhs.obj_name))
      return false;
    return true;
  }
  bool operator != (const OID &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OID & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OID &a, OID &b);

inline std::ostream& operator<<(std::ostream& out, const OID& obj)
{
  obj.printTo(out);
  return out;
}


class OIDS : public virtual ::apache::thrift::TBase {
 public:

  OIDS(const OIDS&);
  OIDS& operator=(const OIDS&);
  OIDS() : path_depth(0), dir_id(0) {
  }

  virtual ~OIDS() throw();
  int16_t path_depth;
  int64_t dir_id;
  std::vector<std::string>  obj_names;

  void __set_path_depth(const int16_t val);

  void __set_dir_id(const int64_t val);

  void __set_obj_names(const std::vector<std::string> & val);

  bool operator == (const OIDS & rhs) const
  {
    if (!(path_depth == rhs.path_depth))
      return false;
    if (!(dir_id == rhs.dir_id))
      return false;
    if (!(obj_names == rhs.obj_names))
      return false;
    return true;
  }
  bool operator != (const OIDS &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OIDS & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OIDS &a, OIDS &b);

inline std::ostream& operator<<(std::ostream& out, const OIDS& obj)
{
  obj.printTo(out);
  return out;
}


class StatInfo : public virtual ::apache::thrift::TBase {
 public:

  StatInfo(const StatInfo&);
  StatInfo& operator=(const StatInfo&);
  StatInfo() : mode(0), uid(0), gid(0), size(0), mtime(0), ctime(0), id(0), zeroth_server(0), is_embedded(0) {
  }

  virtual ~StatInfo() throw();
  int32_t mode;
  int16_t uid;
  int16_t gid;
  int64_t size;
  int64_t mtime;
  int64_t ctime;
  int64_t id;
  int16_t zeroth_server;
  bool is_embedded;

  void __set_mode(const int32_t val);

  void __set_uid(const int16_t val);

  void __set_gid(const int16_t val);

  void __set_size(const int64_t val);

  void __set_mtime(const int64_t val);

  void __set_ctime(const int64_t val);

  void __set_id(const int64_t val);

  void __set_zeroth_server(const int16_t val);

  void __set_is_embedded(const bool val);

  bool operator == (const StatInfo & rhs) const
  {
    if (!(mode == rhs.mode))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(gid == rhs.gid))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(mtime == rhs.mtime))
      return false;
    if (!(ctime == rhs.ctime))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(zeroth_server == rhs.zeroth_server))
      return false;
    if (!(is_embedded == rhs.is_embedded))
      return false;
    return true;
  }
  bool operator != (const StatInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StatInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StatInfo &a, StatInfo &b);

inline std::ostream& operator<<(std::ostream& out, const StatInfo& obj)
{
  obj.printTo(out);
  return out;
}


class LookupInfo : public virtual ::apache::thrift::TBase {
 public:

  LookupInfo(const LookupInfo&);
  LookupInfo& operator=(const LookupInfo&);
  LookupInfo() : id(0), zeroth_server(0), perm(0), uid(0), gid(0), lease_due(0) {
  }

  virtual ~LookupInfo() throw();
  int64_t id;
  int16_t zeroth_server;
  int16_t perm;
  int16_t uid;
  int16_t gid;
  int64_t lease_due;

  void __set_id(const int64_t val);

  void __set_zeroth_server(const int16_t val);

  void __set_perm(const int16_t val);

  void __set_uid(const int16_t val);

  void __set_gid(const int16_t val);

  void __set_lease_due(const int64_t val);

  bool operator == (const LookupInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(zeroth_server == rhs.zeroth_server))
      return false;
    if (!(perm == rhs.perm))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(gid == rhs.gid))
      return false;
    if (!(lease_due == rhs.lease_due))
      return false;
    return true;
  }
  bool operator != (const LookupInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LookupInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LookupInfo &a, LookupInfo &b);

inline std::ostream& operator<<(std::ostream& out, const LookupInfo& obj)
{
  obj.printTo(out);
  return out;
}


class EntryList : public virtual ::apache::thrift::TBase {
 public:

  EntryList(const EntryList&);
  EntryList& operator=(const EntryList&);
  EntryList() : dmap_data() {
  }

  virtual ~EntryList() throw();
  std::string dmap_data;
  std::vector<std::string>  entries;

  void __set_dmap_data(const std::string& val);

  void __set_entries(const std::vector<std::string> & val);

  bool operator == (const EntryList & rhs) const
  {
    if (!(dmap_data == rhs.dmap_data))
      return false;
    if (!(entries == rhs.entries))
      return false;
    return true;
  }
  bool operator != (const EntryList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EntryList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EntryList &a, EntryList &b);

inline std::ostream& operator<<(std::ostream& out, const EntryList& obj)
{
  obj.printTo(out);
  return out;
}


class ScanResult : public virtual ::apache::thrift::TBase {
 public:

  ScanResult(const ScanResult&);
  ScanResult& operator=(const ScanResult&);
  ScanResult() : end_key(), end_partition(0), more_entries(0), dmap_data() {
  }

  virtual ~ScanResult() throw();
  std::vector<std::string>  entries;
  std::string end_key;
  int16_t end_partition;
  int16_t more_entries;
  std::string dmap_data;

  void __set_entries(const std::vector<std::string> & val);

  void __set_end_key(const std::string& val);

  void __set_end_partition(const int16_t val);

  void __set_more_entries(const int16_t val);

  void __set_dmap_data(const std::string& val);

  bool operator == (const ScanResult & rhs) const
  {
    if (!(entries == rhs.entries))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(end_partition == rhs.end_partition))
      return false;
    if (!(more_entries == rhs.more_entries))
      return false;
    if (!(dmap_data == rhs.dmap_data))
      return false;
    return true;
  }
  bool operator != (const ScanResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScanResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScanResult &a, ScanResult &b);

inline std::ostream& operator<<(std::ostream& out, const ScanResult& obj)
{
  obj.printTo(out);
  return out;
}


class ScanPlusResult : public virtual ::apache::thrift::TBase {
 public:

  ScanPlusResult(const ScanPlusResult&);
  ScanPlusResult& operator=(const ScanPlusResult&);
  ScanPlusResult() : end_key(), end_partition(0), more_entries(0), dmap_data() {
  }

  virtual ~ScanPlusResult() throw();
  std::vector<std::string>  names;
  std::vector<StatInfo>  entries;
  std::string end_key;
  int16_t end_partition;
  int16_t more_entries;
  std::string dmap_data;

  void __set_names(const std::vector<std::string> & val);

  void __set_entries(const std::vector<StatInfo> & val);

  void __set_end_key(const std::string& val);

  void __set_end_partition(const int16_t val);

  void __set_more_entries(const int16_t val);

  void __set_dmap_data(const std::string& val);

  bool operator == (const ScanPlusResult & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    if (!(entries == rhs.entries))
      return false;
    if (!(end_key == rhs.end_key))
      return false;
    if (!(end_partition == rhs.end_partition))
      return false;
    if (!(more_entries == rhs.more_entries))
      return false;
    if (!(dmap_data == rhs.dmap_data))
      return false;
    return true;
  }
  bool operator != (const ScanPlusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ScanPlusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ScanPlusResult &a, ScanPlusResult &b);

inline std::ostream& operator<<(std::ostream& out, const ScanPlusResult& obj)
{
  obj.printTo(out);
  return out;
}


class OpenResult : public virtual ::apache::thrift::TBase {
 public:

  OpenResult(const OpenResult&);
  OpenResult& operator=(const OpenResult&);
  OpenResult() : is_embedded(0), data() {
  }

  virtual ~OpenResult() throw();
  bool is_embedded;
  std::string data;

  void __set_is_embedded(const bool val);

  void __set_data(const std::string& val);

  bool operator == (const OpenResult & rhs) const
  {
    if (!(is_embedded == rhs.is_embedded))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const OpenResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OpenResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OpenResult &a, OpenResult &b);

inline std::ostream& operator<<(std::ostream& out, const OpenResult& obj)
{
  obj.printTo(out);
  return out;
}


class ReadResult : public virtual ::apache::thrift::TBase {
 public:

  ReadResult(const ReadResult&);
  ReadResult& operator=(const ReadResult&);
  ReadResult() : is_embedded(0), data() {
  }

  virtual ~ReadResult() throw();
  bool is_embedded;
  std::string data;

  void __set_is_embedded(const bool val);

  void __set_data(const std::string& val);

  bool operator == (const ReadResult & rhs) const
  {
    if (!(is_embedded == rhs.is_embedded))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const ReadResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReadResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReadResult &a, ReadResult &b);

inline std::ostream& operator<<(std::ostream& out, const ReadResult& obj)
{
  obj.printTo(out);
  return out;
}


class WriteResult : public virtual ::apache::thrift::TBase {
 public:

  WriteResult(const WriteResult&);
  WriteResult& operator=(const WriteResult&);
  WriteResult() : is_embedded(0), link(), data() {
  }

  virtual ~WriteResult() throw();
  bool is_embedded;
  std::string link;
  std::string data;

  void __set_is_embedded(const bool val);

  void __set_link(const std::string& val);

  void __set_data(const std::string& val);

  bool operator == (const WriteResult & rhs) const
  {
    if (!(is_embedded == rhs.is_embedded))
      return false;
    if (!(link == rhs.link))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const WriteResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WriteResult &a, WriteResult &b);

inline std::ostream& operator<<(std::ostream& out, const WriteResult& obj)
{
  obj.printTo(out);
  return out;
}


class FileNotFoundException : public ::apache::thrift::TException {
 public:

  FileNotFoundException(const FileNotFoundException&);
  FileNotFoundException& operator=(const FileNotFoundException&);
  FileNotFoundException() {
  }

  virtual ~FileNotFoundException() throw();

  bool operator == (const FileNotFoundException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const FileNotFoundException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileNotFoundException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(FileNotFoundException &a, FileNotFoundException &b);

inline std::ostream& operator<<(std::ostream& out, const FileNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


class FileAlreadyExistsException : public ::apache::thrift::TException {
 public:

  FileAlreadyExistsException(const FileAlreadyExistsException&);
  FileAlreadyExistsException& operator=(const FileAlreadyExistsException&);
  FileAlreadyExistsException() {
  }

  virtual ~FileAlreadyExistsException() throw();

  bool operator == (const FileAlreadyExistsException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const FileAlreadyExistsException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileAlreadyExistsException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(FileAlreadyExistsException &a, FileAlreadyExistsException &b);

inline std::ostream& operator<<(std::ostream& out, const FileAlreadyExistsException& obj)
{
  obj.printTo(out);
  return out;
}


class UnrecognizedDirectoryError : public ::apache::thrift::TException {
 public:

  UnrecognizedDirectoryError(const UnrecognizedDirectoryError&);
  UnrecognizedDirectoryError& operator=(const UnrecognizedDirectoryError&);
  UnrecognizedDirectoryError() {
  }

  virtual ~UnrecognizedDirectoryError() throw();

  bool operator == (const UnrecognizedDirectoryError & /* rhs */) const
  {
    return true;
  }
  bool operator != (const UnrecognizedDirectoryError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnrecognizedDirectoryError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(UnrecognizedDirectoryError &a, UnrecognizedDirectoryError &b);

inline std::ostream& operator<<(std::ostream& out, const UnrecognizedDirectoryError& obj)
{
  obj.printTo(out);
  return out;
}


class WrongServerError : public ::apache::thrift::TException {
 public:

  WrongServerError(const WrongServerError&);
  WrongServerError& operator=(const WrongServerError&);
  WrongServerError() {
  }

  virtual ~WrongServerError() throw();

  bool operator == (const WrongServerError & /* rhs */) const
  {
    return true;
  }
  bool operator != (const WrongServerError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WrongServerError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(WrongServerError &a, WrongServerError &b);

inline std::ostream& operator<<(std::ostream& out, const WrongServerError& obj)
{
  obj.printTo(out);
  return out;
}


class DirectoryExpectedError : public ::apache::thrift::TException {
 public:

  DirectoryExpectedError(const DirectoryExpectedError&);
  DirectoryExpectedError& operator=(const DirectoryExpectedError&);
  DirectoryExpectedError() {
  }

  virtual ~DirectoryExpectedError() throw();

  bool operator == (const DirectoryExpectedError & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DirectoryExpectedError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DirectoryExpectedError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(DirectoryExpectedError &a, DirectoryExpectedError &b);

inline std::ostream& operator<<(std::ostream& out, const DirectoryExpectedError& obj)
{
  obj.printTo(out);
  return out;
}


class FileExpectedError : public ::apache::thrift::TException {
 public:

  FileExpectedError(const FileExpectedError&);
  FileExpectedError& operator=(const FileExpectedError&);
  FileExpectedError() {
  }

  virtual ~FileExpectedError() throw();

  bool operator == (const FileExpectedError & /* rhs */) const
  {
    return true;
  }
  bool operator != (const FileExpectedError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileExpectedError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(FileExpectedError &a, FileExpectedError &b);

inline std::ostream& operator<<(std::ostream& out, const FileExpectedError& obj)
{
  obj.printTo(out);
  return out;
}


class IOError : public ::apache::thrift::TException {
 public:

  IOError(const IOError&);
  IOError& operator=(const IOError&);
  IOError() : message() {
  }

  virtual ~IOError() throw();
  std::string message;

  void __set_message(const std::string& val);

  bool operator == (const IOError & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const IOError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IOError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(IOError &a, IOError &b);

inline std::ostream& operator<<(std::ostream& out, const IOError& obj)
{
  obj.printTo(out);
  return out;
}


class ServerInternalError : public ::apache::thrift::TException {
 public:

  ServerInternalError(const ServerInternalError&);
  ServerInternalError& operator=(const ServerInternalError&);
  ServerInternalError() : message() {
  }

  virtual ~ServerInternalError() throw();
  std::string message;

  void __set_message(const std::string& val);

  bool operator == (const ServerInternalError & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ServerInternalError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerInternalError & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ServerInternalError &a, ServerInternalError &b);

inline std::ostream& operator<<(std::ostream& out, const ServerInternalError& obj)
{
  obj.printTo(out);
  return out;
}


class IllegalPathException : public ::apache::thrift::TException {
 public:

  IllegalPathException(const IllegalPathException&);
  IllegalPathException& operator=(const IllegalPathException&);
  IllegalPathException() {
  }

  virtual ~IllegalPathException() throw();

  bool operator == (const IllegalPathException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IllegalPathException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IllegalPathException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(IllegalPathException &a, IllegalPathException &b);

inline std::ostream& operator<<(std::ostream& out, const IllegalPathException& obj)
{
  obj.printTo(out);
  return out;
}


class ServerRedirectionException : public ::apache::thrift::TException {
 public:

  ServerRedirectionException(const ServerRedirectionException&);
  ServerRedirectionException& operator=(const ServerRedirectionException&);
  ServerRedirectionException() : dmap_data() {
  }

  virtual ~ServerRedirectionException() throw();
  std::string dmap_data;

  void __set_dmap_data(const std::string& val);

  bool operator == (const ServerRedirectionException & rhs) const
  {
    if (!(dmap_data == rhs.dmap_data))
      return false;
    return true;
  }
  bool operator != (const ServerRedirectionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ServerRedirectionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ServerRedirectionException &a, ServerRedirectionException &b);

inline std::ostream& operator<<(std::ostream& out, const ServerRedirectionException& obj)
{
  obj.printTo(out);
  return out;
}


class ParentPathNotFoundException : public ::apache::thrift::TException {
 public:

  ParentPathNotFoundException(const ParentPathNotFoundException&);
  ParentPathNotFoundException& operator=(const ParentPathNotFoundException&);
  ParentPathNotFoundException() : parent_path() {
  }

  virtual ~ParentPathNotFoundException() throw();
  std::string parent_path;

  void __set_parent_path(const std::string& val);

  bool operator == (const ParentPathNotFoundException & rhs) const
  {
    if (!(parent_path == rhs.parent_path))
      return false;
    return true;
  }
  bool operator != (const ParentPathNotFoundException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParentPathNotFoundException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ParentPathNotFoundException &a, ParentPathNotFoundException &b);

inline std::ostream& operator<<(std::ostream& out, const ParentPathNotFoundException& obj)
{
  obj.printTo(out);
  return out;
}


class ParentPathNotDirectoryException : public ::apache::thrift::TException {
 public:

  ParentPathNotDirectoryException(const ParentPathNotDirectoryException&);
  ParentPathNotDirectoryException& operator=(const ParentPathNotDirectoryException&);
  ParentPathNotDirectoryException() : parent_path() {
  }

  virtual ~ParentPathNotDirectoryException() throw();
  std::string parent_path;

  void __set_parent_path(const std::string& val);

  bool operator == (const ParentPathNotDirectoryException & rhs) const
  {
    if (!(parent_path == rhs.parent_path))
      return false;
    return true;
  }
  bool operator != (const ParentPathNotDirectoryException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParentPathNotDirectoryException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(ParentPathNotDirectoryException &a, ParentPathNotDirectoryException &b);

inline std::ostream& operator<<(std::ostream& out, const ParentPathNotDirectoryException& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
