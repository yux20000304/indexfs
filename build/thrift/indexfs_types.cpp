/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "indexfs_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace indexfs {


OID::~OID() throw() {
}


void OID::__set_path_depth(const int16_t val) {
  this->path_depth = val;
}

void OID::__set_dir_id(const int64_t val) {
  this->dir_id = val;
}

void OID::__set_obj_name(const std::string& val) {
  this->obj_name = val;
}

uint32_t OID::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_path_depth = false;
  bool isset_dir_id = false;
  bool isset_obj_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->path_depth);
          isset_path_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dir_id);
          isset_dir_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->obj_name);
          isset_obj_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_path_depth)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dir_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_obj_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OID");

  xfer += oprot->writeFieldBegin("path_depth", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->path_depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->dir_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obj_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->obj_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OID &a, OID &b) {
  using ::std::swap;
  swap(a.path_depth, b.path_depth);
  swap(a.dir_id, b.dir_id);
  swap(a.obj_name, b.obj_name);
}

OID::OID(const OID& other0) {
  path_depth = other0.path_depth;
  dir_id = other0.dir_id;
  obj_name = other0.obj_name;
}
OID& OID::operator=(const OID& other1) {
  path_depth = other1.path_depth;
  dir_id = other1.dir_id;
  obj_name = other1.obj_name;
  return *this;
}
void OID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OID(";
  out << "path_depth=" << to_string(path_depth);
  out << ", " << "dir_id=" << to_string(dir_id);
  out << ", " << "obj_name=" << to_string(obj_name);
  out << ")";
}


OIDS::~OIDS() throw() {
}


void OIDS::__set_path_depth(const int16_t val) {
  this->path_depth = val;
}

void OIDS::__set_dir_id(const int64_t val) {
  this->dir_id = val;
}

void OIDS::__set_obj_names(const std::vector<std::string> & val) {
  this->obj_names = val;
}

uint32_t OIDS::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_path_depth = false;
  bool isset_dir_id = false;
  bool isset_obj_names = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->path_depth);
          isset_path_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dir_id);
          isset_dir_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->obj_names.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->obj_names.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->obj_names[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          isset_obj_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_path_depth)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dir_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_obj_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OIDS::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OIDS");

  xfer += oprot->writeFieldBegin("path_depth", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->path_depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->dir_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obj_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->obj_names.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->obj_names.begin(); _iter7 != this->obj_names.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OIDS &a, OIDS &b) {
  using ::std::swap;
  swap(a.path_depth, b.path_depth);
  swap(a.dir_id, b.dir_id);
  swap(a.obj_names, b.obj_names);
}

OIDS::OIDS(const OIDS& other8) {
  path_depth = other8.path_depth;
  dir_id = other8.dir_id;
  obj_names = other8.obj_names;
}
OIDS& OIDS::operator=(const OIDS& other9) {
  path_depth = other9.path_depth;
  dir_id = other9.dir_id;
  obj_names = other9.obj_names;
  return *this;
}
void OIDS::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OIDS(";
  out << "path_depth=" << to_string(path_depth);
  out << ", " << "dir_id=" << to_string(dir_id);
  out << ", " << "obj_names=" << to_string(obj_names);
  out << ")";
}


StatInfo::~StatInfo() throw() {
}


void StatInfo::__set_mode(const int32_t val) {
  this->mode = val;
}

void StatInfo::__set_uid(const int16_t val) {
  this->uid = val;
}

void StatInfo::__set_gid(const int16_t val) {
  this->gid = val;
}

void StatInfo::__set_size(const int64_t val) {
  this->size = val;
}

void StatInfo::__set_mtime(const int64_t val) {
  this->mtime = val;
}

void StatInfo::__set_ctime(const int64_t val) {
  this->ctime = val;
}

void StatInfo::__set_id(const int64_t val) {
  this->id = val;
}

void StatInfo::__set_zeroth_server(const int16_t val) {
  this->zeroth_server = val;
}

void StatInfo::__set_is_embedded(const bool val) {
  this->is_embedded = val;
}

uint32_t StatInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_mode = false;
  bool isset_uid = false;
  bool isset_gid = false;
  bool isset_size = false;
  bool isset_mtime = false;
  bool isset_ctime = false;
  bool isset_id = false;
  bool isset_zeroth_server = false;
  bool isset_is_embedded = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          isset_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->uid);
          isset_uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gid);
          isset_gid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mtime);
          isset_mtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ctime);
          isset_ctime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->zeroth_server);
          isset_zeroth_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_embedded);
          isset_is_embedded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_mode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mtime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ctime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_zeroth_server)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_embedded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StatInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatInfo");

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gid", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->gid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->mtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ctime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->ctime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zeroth_server", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->zeroth_server);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_embedded", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->is_embedded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatInfo &a, StatInfo &b) {
  using ::std::swap;
  swap(a.mode, b.mode);
  swap(a.uid, b.uid);
  swap(a.gid, b.gid);
  swap(a.size, b.size);
  swap(a.mtime, b.mtime);
  swap(a.ctime, b.ctime);
  swap(a.id, b.id);
  swap(a.zeroth_server, b.zeroth_server);
  swap(a.is_embedded, b.is_embedded);
}

StatInfo::StatInfo(const StatInfo& other10) {
  mode = other10.mode;
  uid = other10.uid;
  gid = other10.gid;
  size = other10.size;
  mtime = other10.mtime;
  ctime = other10.ctime;
  id = other10.id;
  zeroth_server = other10.zeroth_server;
  is_embedded = other10.is_embedded;
}
StatInfo& StatInfo::operator=(const StatInfo& other11) {
  mode = other11.mode;
  uid = other11.uid;
  gid = other11.gid;
  size = other11.size;
  mtime = other11.mtime;
  ctime = other11.ctime;
  id = other11.id;
  zeroth_server = other11.zeroth_server;
  is_embedded = other11.is_embedded;
  return *this;
}
void StatInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatInfo(";
  out << "mode=" << to_string(mode);
  out << ", " << "uid=" << to_string(uid);
  out << ", " << "gid=" << to_string(gid);
  out << ", " << "size=" << to_string(size);
  out << ", " << "mtime=" << to_string(mtime);
  out << ", " << "ctime=" << to_string(ctime);
  out << ", " << "id=" << to_string(id);
  out << ", " << "zeroth_server=" << to_string(zeroth_server);
  out << ", " << "is_embedded=" << to_string(is_embedded);
  out << ")";
}


LookupInfo::~LookupInfo() throw() {
}


void LookupInfo::__set_id(const int64_t val) {
  this->id = val;
}

void LookupInfo::__set_zeroth_server(const int16_t val) {
  this->zeroth_server = val;
}

void LookupInfo::__set_perm(const int16_t val) {
  this->perm = val;
}

void LookupInfo::__set_uid(const int16_t val) {
  this->uid = val;
}

void LookupInfo::__set_gid(const int16_t val) {
  this->gid = val;
}

void LookupInfo::__set_lease_due(const int64_t val) {
  this->lease_due = val;
}

uint32_t LookupInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_zeroth_server = false;
  bool isset_perm = false;
  bool isset_uid = false;
  bool isset_gid = false;
  bool isset_lease_due = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->zeroth_server);
          isset_zeroth_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->perm);
          isset_perm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->uid);
          isset_uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gid);
          isset_gid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lease_due);
          isset_lease_due = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_zeroth_server)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_perm)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lease_due)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LookupInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LookupInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zeroth_server", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->zeroth_server);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perm", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->perm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gid", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->gid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lease_due", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->lease_due);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LookupInfo &a, LookupInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.zeroth_server, b.zeroth_server);
  swap(a.perm, b.perm);
  swap(a.uid, b.uid);
  swap(a.gid, b.gid);
  swap(a.lease_due, b.lease_due);
}

LookupInfo::LookupInfo(const LookupInfo& other12) {
  id = other12.id;
  zeroth_server = other12.zeroth_server;
  perm = other12.perm;
  uid = other12.uid;
  gid = other12.gid;
  lease_due = other12.lease_due;
}
LookupInfo& LookupInfo::operator=(const LookupInfo& other13) {
  id = other13.id;
  zeroth_server = other13.zeroth_server;
  perm = other13.perm;
  uid = other13.uid;
  gid = other13.gid;
  lease_due = other13.lease_due;
  return *this;
}
void LookupInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LookupInfo(";
  out << "id=" << to_string(id);
  out << ", " << "zeroth_server=" << to_string(zeroth_server);
  out << ", " << "perm=" << to_string(perm);
  out << ", " << "uid=" << to_string(uid);
  out << ", " << "gid=" << to_string(gid);
  out << ", " << "lease_due=" << to_string(lease_due);
  out << ")";
}


EntryList::~EntryList() throw() {
}


void EntryList::__set_dmap_data(const std::string& val) {
  this->dmap_data = val;
}

void EntryList::__set_entries(const std::vector<std::string> & val) {
  this->entries = val;
}

uint32_t EntryList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dmap_data = false;
  bool isset_entries = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dmap_data);
          isset_dmap_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->entries.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readString(this->entries[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          isset_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dmap_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EntryList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EntryList");

  xfer += oprot->writeFieldBegin("dmap_data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dmap_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->entries.size()));
    std::vector<std::string> ::const_iterator _iter19;
    for (_iter19 = this->entries.begin(); _iter19 != this->entries.end(); ++_iter19)
    {
      xfer += oprot->writeString((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EntryList &a, EntryList &b) {
  using ::std::swap;
  swap(a.dmap_data, b.dmap_data);
  swap(a.entries, b.entries);
}

EntryList::EntryList(const EntryList& other20) {
  dmap_data = other20.dmap_data;
  entries = other20.entries;
}
EntryList& EntryList::operator=(const EntryList& other21) {
  dmap_data = other21.dmap_data;
  entries = other21.entries;
  return *this;
}
void EntryList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EntryList(";
  out << "dmap_data=" << to_string(dmap_data);
  out << ", " << "entries=" << to_string(entries);
  out << ")";
}


ScanResult::~ScanResult() throw() {
}


void ScanResult::__set_entries(const std::vector<std::string> & val) {
  this->entries = val;
}

void ScanResult::__set_end_key(const std::string& val) {
  this->end_key = val;
}

void ScanResult::__set_end_partition(const int16_t val) {
  this->end_partition = val;
}

void ScanResult::__set_more_entries(const int16_t val) {
  this->more_entries = val;
}

void ScanResult::__set_dmap_data(const std::string& val) {
  this->dmap_data = val;
}

uint32_t ScanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_entries = false;
  bool isset_end_key = false;
  bool isset_end_partition = false;
  bool isset_more_entries = false;
  bool isset_dmap_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->entries.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readString(this->entries[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          isset_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_key);
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->end_partition);
          isset_end_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->more_entries);
          isset_more_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dmap_data);
          isset_dmap_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_more_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dmap_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanResult");

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->entries.size()));
    std::vector<std::string> ::const_iterator _iter27;
    for (_iter27 = this->entries.begin(); _iter27 != this->entries.end(); ++_iter27)
    {
      xfer += oprot->writeString((*_iter27));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_partition", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->end_partition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more_entries", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->more_entries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dmap_data", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->dmap_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanResult &a, ScanResult &b) {
  using ::std::swap;
  swap(a.entries, b.entries);
  swap(a.end_key, b.end_key);
  swap(a.end_partition, b.end_partition);
  swap(a.more_entries, b.more_entries);
  swap(a.dmap_data, b.dmap_data);
}

ScanResult::ScanResult(const ScanResult& other28) {
  entries = other28.entries;
  end_key = other28.end_key;
  end_partition = other28.end_partition;
  more_entries = other28.more_entries;
  dmap_data = other28.dmap_data;
}
ScanResult& ScanResult::operator=(const ScanResult& other29) {
  entries = other29.entries;
  end_key = other29.end_key;
  end_partition = other29.end_partition;
  more_entries = other29.more_entries;
  dmap_data = other29.dmap_data;
  return *this;
}
void ScanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanResult(";
  out << "entries=" << to_string(entries);
  out << ", " << "end_key=" << to_string(end_key);
  out << ", " << "end_partition=" << to_string(end_partition);
  out << ", " << "more_entries=" << to_string(more_entries);
  out << ", " << "dmap_data=" << to_string(dmap_data);
  out << ")";
}


ScanPlusResult::~ScanPlusResult() throw() {
}


void ScanPlusResult::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void ScanPlusResult::__set_entries(const std::vector<StatInfo> & val) {
  this->entries = val;
}

void ScanPlusResult::__set_end_key(const std::string& val) {
  this->end_key = val;
}

void ScanPlusResult::__set_end_partition(const int16_t val) {
  this->end_partition = val;
}

void ScanPlusResult::__set_more_entries(const int16_t val) {
  this->more_entries = val;
}

void ScanPlusResult::__set_dmap_data(const std::string& val) {
  this->dmap_data = val;
}

uint32_t ScanPlusResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_names = false;
  bool isset_entries = false;
  bool isset_end_key = false;
  bool isset_end_partition = false;
  bool isset_more_entries = false;
  bool isset_dmap_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->names.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readString(this->names[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          isset_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->entries.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->entries[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_key);
          isset_end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->end_partition);
          isset_end_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->more_entries);
          isset_more_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dmap_data);
          isset_dmap_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_more_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dmap_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ScanPlusResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScanPlusResult");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter40;
    for (_iter40 = this->names.begin(); _iter40 != this->names.end(); ++_iter40)
    {
      xfer += oprot->writeString((*_iter40));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entries.size()));
    std::vector<StatInfo> ::const_iterator _iter41;
    for (_iter41 = this->entries.begin(); _iter41 != this->entries.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->end_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_partition", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->end_partition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("more_entries", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->more_entries);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dmap_data", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dmap_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScanPlusResult &a, ScanPlusResult &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.entries, b.entries);
  swap(a.end_key, b.end_key);
  swap(a.end_partition, b.end_partition);
  swap(a.more_entries, b.more_entries);
  swap(a.dmap_data, b.dmap_data);
}

ScanPlusResult::ScanPlusResult(const ScanPlusResult& other42) {
  names = other42.names;
  entries = other42.entries;
  end_key = other42.end_key;
  end_partition = other42.end_partition;
  more_entries = other42.more_entries;
  dmap_data = other42.dmap_data;
}
ScanPlusResult& ScanPlusResult::operator=(const ScanPlusResult& other43) {
  names = other43.names;
  entries = other43.entries;
  end_key = other43.end_key;
  end_partition = other43.end_partition;
  more_entries = other43.more_entries;
  dmap_data = other43.dmap_data;
  return *this;
}
void ScanPlusResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScanPlusResult(";
  out << "names=" << to_string(names);
  out << ", " << "entries=" << to_string(entries);
  out << ", " << "end_key=" << to_string(end_key);
  out << ", " << "end_partition=" << to_string(end_partition);
  out << ", " << "more_entries=" << to_string(more_entries);
  out << ", " << "dmap_data=" << to_string(dmap_data);
  out << ")";
}


OpenResult::~OpenResult() throw() {
}


void OpenResult::__set_is_embedded(const bool val) {
  this->is_embedded = val;
}

void OpenResult::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t OpenResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_embedded = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_embedded);
          isset_is_embedded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_embedded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OpenResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OpenResult");

  xfer += oprot->writeFieldBegin("is_embedded", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_embedded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OpenResult &a, OpenResult &b) {
  using ::std::swap;
  swap(a.is_embedded, b.is_embedded);
  swap(a.data, b.data);
}

OpenResult::OpenResult(const OpenResult& other44) {
  is_embedded = other44.is_embedded;
  data = other44.data;
}
OpenResult& OpenResult::operator=(const OpenResult& other45) {
  is_embedded = other45.is_embedded;
  data = other45.data;
  return *this;
}
void OpenResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OpenResult(";
  out << "is_embedded=" << to_string(is_embedded);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


ReadResult::~ReadResult() throw() {
}


void ReadResult::__set_is_embedded(const bool val) {
  this->is_embedded = val;
}

void ReadResult::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t ReadResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_embedded = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_embedded);
          isset_is_embedded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_embedded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ReadResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReadResult");

  xfer += oprot->writeFieldBegin("is_embedded", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_embedded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReadResult &a, ReadResult &b) {
  using ::std::swap;
  swap(a.is_embedded, b.is_embedded);
  swap(a.data, b.data);
}

ReadResult::ReadResult(const ReadResult& other46) {
  is_embedded = other46.is_embedded;
  data = other46.data;
}
ReadResult& ReadResult::operator=(const ReadResult& other47) {
  is_embedded = other47.is_embedded;
  data = other47.data;
  return *this;
}
void ReadResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReadResult(";
  out << "is_embedded=" << to_string(is_embedded);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


WriteResult::~WriteResult() throw() {
}


void WriteResult::__set_is_embedded(const bool val) {
  this->is_embedded = val;
}

void WriteResult::__set_link(const std::string& val) {
  this->link = val;
}

void WriteResult::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t WriteResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_embedded = false;
  bool isset_link = false;
  bool isset_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_embedded);
          isset_is_embedded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->link);
          isset_link = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_embedded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_link)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WriteResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WriteResult");

  xfer += oprot->writeFieldBegin("is_embedded", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_embedded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("link", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->link);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WriteResult &a, WriteResult &b) {
  using ::std::swap;
  swap(a.is_embedded, b.is_embedded);
  swap(a.link, b.link);
  swap(a.data, b.data);
}

WriteResult::WriteResult(const WriteResult& other48) {
  is_embedded = other48.is_embedded;
  link = other48.link;
  data = other48.data;
}
WriteResult& WriteResult::operator=(const WriteResult& other49) {
  is_embedded = other49.is_embedded;
  link = other49.link;
  data = other49.data;
  return *this;
}
void WriteResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WriteResult(";
  out << "is_embedded=" << to_string(is_embedded);
  out << ", " << "link=" << to_string(link);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


FileNotFoundException::~FileNotFoundException() throw() {
}


uint32_t FileNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileNotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileNotFoundException &a, FileNotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

FileNotFoundException::FileNotFoundException(const FileNotFoundException& other50) : TException() {
  (void) other50;
}
FileNotFoundException& FileNotFoundException::operator=(const FileNotFoundException& other51) {
  (void) other51;
  return *this;
}
void FileNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileNotFoundException(";
  out << ")";
}

const char* FileNotFoundException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: FileNotFoundException";
  }
}


FileAlreadyExistsException::~FileAlreadyExistsException() throw() {
}


uint32_t FileAlreadyExistsException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileAlreadyExistsException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileAlreadyExistsException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileAlreadyExistsException &a, FileAlreadyExistsException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

FileAlreadyExistsException::FileAlreadyExistsException(const FileAlreadyExistsException& other52) : TException() {
  (void) other52;
}
FileAlreadyExistsException& FileAlreadyExistsException::operator=(const FileAlreadyExistsException& other53) {
  (void) other53;
  return *this;
}
void FileAlreadyExistsException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileAlreadyExistsException(";
  out << ")";
}

const char* FileAlreadyExistsException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: FileAlreadyExistsException";
  }
}


UnrecognizedDirectoryError::~UnrecognizedDirectoryError() throw() {
}


uint32_t UnrecognizedDirectoryError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnrecognizedDirectoryError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnrecognizedDirectoryError");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnrecognizedDirectoryError &a, UnrecognizedDirectoryError &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

UnrecognizedDirectoryError::UnrecognizedDirectoryError(const UnrecognizedDirectoryError& other54) : TException() {
  (void) other54;
}
UnrecognizedDirectoryError& UnrecognizedDirectoryError::operator=(const UnrecognizedDirectoryError& other55) {
  (void) other55;
  return *this;
}
void UnrecognizedDirectoryError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnrecognizedDirectoryError(";
  out << ")";
}

const char* UnrecognizedDirectoryError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: UnrecognizedDirectoryError";
  }
}


WrongServerError::~WrongServerError() throw() {
}


uint32_t WrongServerError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WrongServerError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WrongServerError");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WrongServerError &a, WrongServerError &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

WrongServerError::WrongServerError(const WrongServerError& other56) : TException() {
  (void) other56;
}
WrongServerError& WrongServerError::operator=(const WrongServerError& other57) {
  (void) other57;
  return *this;
}
void WrongServerError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WrongServerError(";
  out << ")";
}

const char* WrongServerError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: WrongServerError";
  }
}


DirectoryExpectedError::~DirectoryExpectedError() throw() {
}


uint32_t DirectoryExpectedError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DirectoryExpectedError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DirectoryExpectedError");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DirectoryExpectedError &a, DirectoryExpectedError &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

DirectoryExpectedError::DirectoryExpectedError(const DirectoryExpectedError& other58) : TException() {
  (void) other58;
}
DirectoryExpectedError& DirectoryExpectedError::operator=(const DirectoryExpectedError& other59) {
  (void) other59;
  return *this;
}
void DirectoryExpectedError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DirectoryExpectedError(";
  out << ")";
}

const char* DirectoryExpectedError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: DirectoryExpectedError";
  }
}


FileExpectedError::~FileExpectedError() throw() {
}


uint32_t FileExpectedError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileExpectedError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileExpectedError");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileExpectedError &a, FileExpectedError &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

FileExpectedError::FileExpectedError(const FileExpectedError& other60) : TException() {
  (void) other60;
}
FileExpectedError& FileExpectedError::operator=(const FileExpectedError& other61) {
  (void) other61;
  return *this;
}
void FileExpectedError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileExpectedError(";
  out << ")";
}

const char* FileExpectedError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: FileExpectedError";
  }
}


IOError::~IOError() throw() {
}


void IOError::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t IOError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IOError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IOError");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IOError &a, IOError &b) {
  using ::std::swap;
  swap(a.message, b.message);
}

IOError::IOError(const IOError& other62) : TException() {
  message = other62.message;
}
IOError& IOError::operator=(const IOError& other63) {
  message = other63.message;
  return *this;
}
void IOError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IOError(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* IOError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IOError";
  }
}


ServerInternalError::~ServerInternalError() throw() {
}


void ServerInternalError::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t ServerInternalError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_message = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          isset_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_message)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerInternalError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerInternalError");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerInternalError &a, ServerInternalError &b) {
  using ::std::swap;
  swap(a.message, b.message);
}

ServerInternalError::ServerInternalError(const ServerInternalError& other64) : TException() {
  message = other64.message;
}
ServerInternalError& ServerInternalError::operator=(const ServerInternalError& other65) {
  message = other65.message;
  return *this;
}
void ServerInternalError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerInternalError(";
  out << "message=" << to_string(message);
  out << ")";
}

const char* ServerInternalError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ServerInternalError";
  }
}


IllegalPathException::~IllegalPathException() throw() {
}


uint32_t IllegalPathException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IllegalPathException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IllegalPathException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IllegalPathException &a, IllegalPathException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

IllegalPathException::IllegalPathException(const IllegalPathException& other66) : TException() {
  (void) other66;
}
IllegalPathException& IllegalPathException::operator=(const IllegalPathException& other67) {
  (void) other67;
  return *this;
}
void IllegalPathException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IllegalPathException(";
  out << ")";
}

const char* IllegalPathException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: IllegalPathException";
  }
}


ServerRedirectionException::~ServerRedirectionException() throw() {
}


void ServerRedirectionException::__set_dmap_data(const std::string& val) {
  this->dmap_data = val;
}

uint32_t ServerRedirectionException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dmap_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dmap_data);
          isset_dmap_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dmap_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerRedirectionException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerRedirectionException");

  xfer += oprot->writeFieldBegin("dmap_data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dmap_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerRedirectionException &a, ServerRedirectionException &b) {
  using ::std::swap;
  swap(a.dmap_data, b.dmap_data);
}

ServerRedirectionException::ServerRedirectionException(const ServerRedirectionException& other68) : TException() {
  dmap_data = other68.dmap_data;
}
ServerRedirectionException& ServerRedirectionException::operator=(const ServerRedirectionException& other69) {
  dmap_data = other69.dmap_data;
  return *this;
}
void ServerRedirectionException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerRedirectionException(";
  out << "dmap_data=" << to_string(dmap_data);
  out << ")";
}

const char* ServerRedirectionException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ServerRedirectionException";
  }
}


ParentPathNotFoundException::~ParentPathNotFoundException() throw() {
}


void ParentPathNotFoundException::__set_parent_path(const std::string& val) {
  this->parent_path = val;
}

uint32_t ParentPathNotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_parent_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_path);
          isset_parent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_parent_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParentPathNotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParentPathNotFoundException");

  xfer += oprot->writeFieldBegin("parent_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->parent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParentPathNotFoundException &a, ParentPathNotFoundException &b) {
  using ::std::swap;
  swap(a.parent_path, b.parent_path);
}

ParentPathNotFoundException::ParentPathNotFoundException(const ParentPathNotFoundException& other70) : TException() {
  parent_path = other70.parent_path;
}
ParentPathNotFoundException& ParentPathNotFoundException::operator=(const ParentPathNotFoundException& other71) {
  parent_path = other71.parent_path;
  return *this;
}
void ParentPathNotFoundException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParentPathNotFoundException(";
  out << "parent_path=" << to_string(parent_path);
  out << ")";
}

const char* ParentPathNotFoundException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ParentPathNotFoundException";
  }
}


ParentPathNotDirectoryException::~ParentPathNotDirectoryException() throw() {
}


void ParentPathNotDirectoryException::__set_parent_path(const std::string& val) {
  this->parent_path = val;
}

uint32_t ParentPathNotDirectoryException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_parent_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_path);
          isset_parent_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_parent_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParentPathNotDirectoryException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParentPathNotDirectoryException");

  xfer += oprot->writeFieldBegin("parent_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->parent_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParentPathNotDirectoryException &a, ParentPathNotDirectoryException &b) {
  using ::std::swap;
  swap(a.parent_path, b.parent_path);
}

ParentPathNotDirectoryException::ParentPathNotDirectoryException(const ParentPathNotDirectoryException& other72) : TException() {
  parent_path = other72.parent_path;
}
ParentPathNotDirectoryException& ParentPathNotDirectoryException::operator=(const ParentPathNotDirectoryException& other73) {
  parent_path = other73.parent_path;
  return *this;
}
void ParentPathNotDirectoryException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParentPathNotDirectoryException(";
  out << "parent_path=" << to_string(parent_path);
  out << ")";
}

const char* ParentPathNotDirectoryException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ParentPathNotDirectoryException";
  }
}

} // namespace
